Примеры и команды конфигурации подов: [examples](examples/)

# Pods

Pod'ы — это наименьшие и простейшие объекты в модели развертывания Kubernetes. Вы создаете и управляете Pod'ами, а Kubernetes автоматически размещает их на нодах кластера.  
Pod (как в «pod of whales» или «pod of pea») — это группа из одного или нескольких контейнеров с общим хранилищем и сетевыми ресурсами, а также спецификацией для запуска контейнеров. Содержимое Pod всегда находится в одном месте и запускается одновременно, а также работает в общем контексте. Pod моделирует «логический хост» для конкретного приложения: он содержит один или несколько контейнеров приложений, которые относительно тесно связаны между собой. В необлачных средах приложения, выполняемые на одной физической или виртуальной машине, аналогичны облачным приложениям, выполняемым на одном логическом хосте.  
Помимо контейнеров приложений, модуль может содержать контейнеры инициализации, которые запускаются при запуске модуля. Вы также можете внедрять временные контейнеры для отладки работающего модуля

## Как Kubernetes использует Pod'ы

Kubernetes использует Pod'ы как основную единицу для управления контейнерами. Каждый Pod содержит один или несколько связанных контейнеров, которые должны быть запущены вместе. Pod'ы абстрагируют отдельные контейнеры, позволяя Kubernetes управлять ими как единым целым.

### Основные характеристики Pod'ов:

1. **Общие ресурсы**: Контейнеры в Pod'е разделяют IP-адрес и портовое пространство, могут находить друг друга через `localhost`​, и могут общаться между собой используя стандартные межпроцессные коммуникации, такие как SystemV семафоры или POSIX разделяемая память.
2. **Общие тома**: Pod'ы могут определять набор томов (volumes), которые доступны всем контейнерам в Pod'е. Это позволяет контейнерам обмениваться данными и сохранять состояние между перезапусками.
3. **Жизненный цикл**: Pod'ы следуют предопределенному жизненному циклу, начиная с фазы `Pending`​, затем `Running`​, и заканчивая либо `Succeeded`​, либо `Failed`​ в зависимости от состояния их контейнеров.

## Что такое Pod?

Общий контекст поды — это набор пространств имён Linux, контрольных групп и, возможно, других аспектов изоляции — тех же, что изолируют контейнер. В контексте поды к отдельным приложениям могут применяться дополнительные меры изоляции.  
Pod похож на набор контейнеров с общими пространствами имён и общими томами файловой системы.  
Модули в кластере Kubernetes используются двумя основными способами:

* Поды, в которых работает один контейнер. Модель «один контейнер на один под» является наиболее распространённым вариантом использования Kubernetes. В этом случае под можно рассматривать как оболочку для одного контейнера. Kubernetes управляет подами, а не контейнерами напрямую.
* Pods, в которых запущено несколько контейнеров, которые должны работать вместе. Pod может инкапсулировать приложение, состоящее из нескольких совместно используемых контейнеров, которые тесно связаны и должны совместно использовать ресурсы. Эти совместно используемые контейнеры образуют единое целое.  
  Объединение нескольких совместно размещённых и управляемых контейнеров в один модуль — относительно сложный вариант использования. Этот шаблон следует применять только в особых случаях, когда ваши контейнеры тесно связаны между собой.  
  Вам не нужно запускать несколько контейнеров для обеспечения репликации (для отказоустойчивости или увеличения производительности)

## Использование Pods

Обычно Pod'ы создаются как часть более высокоуровневых абстракций, таких как:

* Deployments
* StatefulSets
* DaemonSets
* Jobs

Но можно создавать и отдельные Pod'ы напрямую (например, для отладки).

Ниже приведён пример модуля, состоящего из контейнера с образом `nginx:1.14.2`​.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.14.2
    ports:
    - containerPort: 80
```

Чтобы создать pod, показанный выше, выполните следующую команду:

```shell
kubectl apply -f 	simple-pod.yaml
```

Как правило, модули не создаются напрямую, а создаются с помощью ресурсов рабочей нагрузки.

## Шаблон Pod'а (Pod Template)

Шаблоны Pod'ов используются в контроллерах (например, Deployments) для создания Pod'ов. Они содержат спецификацию Pod'а, включая:

* Список контейнеров и их образы
* Тома, которые должны быть подключены
* Переменные окружения
* Политики перезапуска
* Требования к ресурсам и ограничения
* Настройки сети
* И многое другое

Приведённый ниже пример — это манифест для простого задания с `template`​ , которое запускает один контейнер. Контейнер в этом pod выводит сообщение, а затем приостанавливается.

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: hello
spec:
  template:
    # This is the pod template
    spec:
      containers:
      - name: hello
        image: busybox:1.28
        command: ['sh', '-c', 'echo "Hello, Kubernetes!" && sleep 3600']
      restartPolicy: OnFailure
    # The pod template ends here
```

## Жизненный цикл Pod'а

Pod проходит несколько фаз:

1. **Pending**: Pod принят Kubernetes, но его контейнеры еще не запущены.
2. **Running**: Pod привязан к ноде, и все контейнеры запущены.
3. **Succeeded**: Все контейнеры завершились успешно и не будут перезапущены.
4. **Failed**: По крайней мере один контейнер завершился с ошибкой.
5. **Unknown**: Состояние Pod'а не может быть определено (обычно из-за проблем связи с нодой).

## Сетевые особенности

Каждый Pod получает уникальный IP-адрес в кластере. Все контейнеры внутри Pod'а разделяют одно сетевое пространство имен и могут общаться друг с другом через `localhost`​. Контейнеры в разных Pod'ах должны общаться через сервисы или другие механизмы.

## Хранение данных

Pod'ы могут определять тома (volumes), которые доступны всем контейнерам в Pod'е. Существуют различные типы томов:

* ​`emptyDir`​: Временное хранилище, существующее только пока жив Pod
* ​`hostPath`​: Доступ к файловой системе ноды
* ​`configMap`​, `secret`​: Для конфигурации и секретов
* ​`persistentVolumeClaim`​: Для постоянного хранения данных
* И многие другие специализированные типы томов

## Ресурсы и ограничения

Вы можете задавать запросы ресурсов (requests) и ограничения (limits) для контейнеров в Pod'е:

```yaml
resources:
  requests:
    memory: "64Mi"
    cpu: "250m"
  limits:
    memory: "128Mi"
    cpu: "500m"
```

Где:

* ​`requests`​ определяет гарантированные ресурсы
* ​`limits`​ определяет максимальные доступные ресурсы

## Политика перезапуска (restartPolicy)

Определяет поведение Kubernetes при завершении контейнеров:

* ​`Always`​: Всегда перезапускать контейнер (по умолчанию для Pod'ов в контроллерах)
* ​`OnFailure`​: Перезапускать только при неудачном завершении
* ​`Never`​: Никогда не перезапускать

## Операционная система Pod (Pod OS)

**Состояние функции:**   
Kubernetes v1.25 [стабильно]

В спецификации Pod можно указать операционную систему, на которой должен работать Pod, используя поле `.spec.os.name`​. Допустимые значения:

* ​`linux`​ (по умолчанию)
* ​`windows`​

На данный момент Kubernetes поддерживает только эти две ОС, но в будущем список может быть расширен.

**Важные нюансы:**

1. **В Kubernetes v1.32** значение `.spec.os.name`​ не влияет на выбор ноды планировщиком (`kube-scheduler`​). Для кластеров с нодами разных ОС необходимо:

    * Правильно настроить метку `kubernetes.io/os`​ на каждой ноде
    * Использовать `nodeSelector`​ в Pod с указанием нужной ОС
2. **Безопасность:**   
    Стандарты безопасности Pod (Pod Security Standards) используют это поле для применения политик, соответствующих указанной ОС.
3. **Планирование:**   
    Планировщик выбирает ноду на основе других критериев и может случайно назначить Pod на ноду с неподходящей ОС, если не заданы явные правила селектора.

‍

## Безопасность Pod'ов (Pod Security)

Для настройки ограничений безопасности Pod'ов и их контейнеров используется поле `securityContext`​ в спецификации Pod. Это поле позволяет детально контролировать разрешения и возможности Pod'а или отдельных контейнеров. Например, вы можете:

* **Отключать определенные Linux-возможности (capabilities)** , чтобы минимизировать последствия уязвимостей (например, CVE).
* **Запускать все процессы в Pod'е от имени непривилегированного пользователя** (non-root) или конкретных пользователя/группы (user/group ID).
* **Настраивать seccomp-профили** для ограничения системных вызовов.
* **Устанавливать политики безопасности для Windows** (если Pod работает на узлах с Windows).

### Пример настройки securityContext

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: security-context-demo
spec:
  securityContext:
    runAsUser: 1000
    runAsGroup: 3000
    fsGroup: 2000
  containers:
  - name: sec-ctx-demo
    image: busybox:1.28
    command: ["sh", "-c", "sleep 1h"]
    securityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop: ["ALL"]
        add: ["NET_ADMIN"]
```

### Ключевые возможности securityContext:

1. **На уровне Pod'а**:

    * ​`runAsUser`​/`runAsGroup`​ — UID/GID для всех контейнеров
    * ​`fsGroup`​ — группа для томов Pod'а
    * ​`seccompProfile`​ — глобальный профиль безопасности
2. **На уровне контейнера**:

    * ​`privileged`​ — запрет/разрешение привилегированного режима
    * ​`readOnlyRootFilesystem`​ — монтирование корневой ФС только для чтения
    * ​`capabilities`​ — тонкая настройка Linux-возможностей

‍

## Статические Pod'ы (Static Pods)

Статические Pod'ы — это Pod'ы, управляемые напрямую демоном kubelet на конкретном узле, без взаимодействия с API-сервером Kubernetes. В отличие от обычных Pod'ов, которые создаются через контрольную плоскость Kubernetes (например, через Deployment или непосредственно через API), статические Pod'ы определяются непосредственно на узле.

### Как работают статические Pod'ы

1. **Конфигурация**:  
    Администратор кластера размещает файлы манифестов Pod'ов в специальном каталоге, который отслеживает kubelet (обычно `/etc/kubernetes/manifests`​).
2. **Обнаружение**:  
    Kubelet периодически проверяет указанный каталог на наличие новых или измененных файлов манифестов.
3. **Создание**:  
    При обнаружении нового манифеста kubelet автоматически создает Pod, описанный в этом файле.
4. **Управление**:  
    Kubelet отвечает за поддержание жизненного цикла статического Pod'а (перезапуск при падении и т.д.).

### Особенности статических Pod'ов

* **Видимость в API**: Хотя статические Pod'ы создаются напрямую kubelet, они все равно отображаются в Kubernetes API, но с особым признаком.
* **Имена**: Имена статических Pod'ов автоматически дополняются именем узла (например, `static-web-node1`​).
* **Удаление**: Чтобы удалить статический Pod, нужно удалить его манифест из конфигурационного каталога.
* **Приоритет**: Если статический Pod с таким именем уже существует в API (созданный другим способом), kubelet отказывается его создавать.

### Типичные сценарии использования

1. **Запуск компонентов control plane**:  
    Часто компоненты вроде kube-apiserver, kube-scheduler и kube-controller-manager запускаются как статические Pod'ы.
2. **Системные сервисы узла**:  
    Сервисы, которые должны работать на конкретном узле независимо от состояния кластера.
3. **Разработка и тестирование**:  
    Быстрый запуск Pod'ов без необходимости взаимодействия с API-сервером.

### Пример конфигурации

1. Настройте kubelet с параметром `--pod-manifest-path=/etc/kubernetes/manifests`​ (или укажите в конфигурационном файле kubelet).
2. Создайте файл манифеста, например `/etc/kubernetes/manifests/static-web.yaml`​:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: static-web
  labels:
    role: myrole
spec:
  containers:
    - name: web
      image: nginx
      ports:
        - name: web
          containerPort: 80
          protocol: TCP
```

### Важные замечания

* Статические Pod'ы не могут использовать некоторые функции Kubernetes, такие как ConfigMaps или Secrets, если они не смонтированы вручную.
* Для мониторинга состояния статических Pod'ов можно использовать `kubectl get pods`​, но управлять ими через API Kubernetes нельзя.
* При изменении манифеста kubelet автоматически обновит Pod.

Статические Pod'ы предоставляют простой способ запуска Pod'ов на узлах без необходимости в работающей контрольной плоскости Kubernetes, что особенно полезно для bootstrap самого кластера.

### Стандарты безопасности Pod'ов (Pod Security Standards)

Kubernetes предоставляет предопределенные профили безопасности:

* **Privileged**: Без ограничений (для системных workloads)
* **Baseline**: Минимальные ограничения, совместимые с большинством приложений
* **Restricted**: Строгие ограничения, соответствующие лучшим практикам

Эти стандарты используют поле `.spec.os.name`​ для корректного применения политик в зависимости от ОС Pod'а (Linux/Windows).

## Проверки контейнеров (Container Probes)

*Probes* — это механизм диагностики, периодически выполняемый kubelet для проверки состояния контейнера. Существует три типа проверок:

### 1. **Проверка жизнеспособности (livenessProbe)**

Определяет, нужно ли перезапустить контейнер.  
Пример сценария:

* Контейнер запущен, но завис (deadlock)
* Приложение работает, но не может обрабатывать запросы
* В таких случаях kubelet убивает и перезапускает контейнер

### 2. **Проверка готовности (readinessProbe)**

Определяет, готов ли контейнер принимать трафик.  
Если проверка fails:

* Pod удаляется из Service Endpoints
* Входящие запросы не направляются на этот Pod

### 3. **Стартовая проверка (startupProbe)**

(Доступно с Kubernetes v1.16+)  
Определяет, когда контейнер завершил запуск.  
Особенности:

* Отключает другие проверки до успешного завершения
* Полезно для медленно стартующих приложений

### Способы выполнения проверок

1. **Exec-команда**  
    Выполняет команду внутри контейнера (код возврата 0 \= успех)  

    ```yaml
    livenessProbe:
      exec:
        command:
        - cat
        - /tmp/healthy
    ```
2. **HTTP-запрос**  
    Проверяет HTTP-код ответа (2xx/3xx \= успех)  

    ```yaml
    readinessProbe:
      httpGet:
        path: /healthz
        port: 8080
        httpHeaders:
        - name: Custom-Header
          value: Awesome
    ```
3. **TCP-соединение**  
    Успех, если установлено соединение с портом  

    ```yaml
    startupProbe:
      tcpSocket:
        port: 8080
    ```

### Общие параметры конфигурации

Для всех типов проверок доступны параметры:

|Параметр|Описание|По умолчанию|
| ------------------| ----------------------------------------------------------------| -------------------------|
|​`initialDelaySeconds`​|Задержка перед первой проверкой|0|
|​`periodSeconds`​|Интервал между проверками|10|
|​`timeoutSeconds`​|Таймаут проверки|1|
|​`successThreshold`​|Число успешных попыток для успеха|1|
|​`failureThreshold`​|Число неудач для провала|3|

### Пример полной конфигурации

```yaml
apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness-exec
spec:
  containers:
  - name: liveness
    image: registry.k8s.io/busybox
    args:
    - /bin/sh
    - -c
    - touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600
    livenessProbe:
      exec:
        command:
        - cat
        - /tmp/healthy
      initialDelaySeconds: 5
      periodSeconds: 5
```

### Рекомендации по использованию

1. **Для livenessProbe**:

    * Используйте консервативные параметры (длинные таймауты)
    * Не делайте зависимыми от внешних сервисов
2. **Для readinessProbe**:

    * Проверяйте все критические зависимости
    * Учитывайте время "разогрева" приложения
3. **Для startupProbe**:

    * Устанавливайте достаточно большой `failureThreshold`​
    * Используйте тот же endpoint, что и livenessProbe

Важно: Неправильно настроенные проверки могут привести к бесконечным перезапускам Pod'ов!

## Как Pod'ы управляют несколькими контейнерами

Pod'ы предназначены для поддержки нескольких тесно связанных процессов (в виде контейнеров), которые работают вместе как единое приложение. Контейнеры в одном Pod'е:

1. **Разделяют IP-адрес и пространство портов**

    * Могут общаться друг с другом через `localhost`​
    * Должны координировать использование портов
2. **Имеют общие тома (volumes)**

    * Могут совместно использовать данные через общие точки монтирования
    * Пример: контейнер веб-сервера и контейнер для обновления контента
3. **Запускаются и завершаются вместе**

    * Нет понятия "перезапуска отдельного контейнера" — весь Pod перезапускается
    * Общий жизненный цикл

![image](assets/image-20250415173259-i1zih91.png)​

### Типичные шаблоны использования нескольких контейнеров

#### 1. Sidecar-паттерн (Вспомогательный контейнер)

Пример:

* Основной контейнер: веб-сервер
* Sidecar: синхронизатор файлов/лог-ротейтер

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-server
spec:
  containers:
  - name: web
    image: nginx
    volumeMounts:
    - name: shared-logs
      mountPath: /var/log/nginx
  - name: log-processor
    image: busybox
    command: ["sh", "-c", "tail -f /var/log/nginx/access.log"]
    volumeMounts:
    - name: shared-logs
      mountPath: /var/log/nginx
  volumes:
  - name: shared-logs
    emptyDir: {}
```

#### 2. Adapter-паттерн (Адаптер)

Пример:

* Основной контейнер: приложение со своим форматом логов
* Адаптер: преобразует логи в стандартный формат

#### 3. Ambassador-паттерн (Посредник)

Пример:

* Основной контейнер: приложение
* Ambassador: проксирует соединения к внешним сервисам

### Особенности управления

1. **Общие ресурсы**

    * Память/CPU ограничиваются на уровне Pod'а
    * ​`kubectl top pod`​ показывает совокупное использование
2. **Сетевые порты**

    * Контейнеры не могут использовать одинаковые порты
3. **Статус Pod'а**

    * Общий статус определяется по всем контейнерам
    * ​`kubectl describe pod`​ показывает детали по каждому

### Практические рекомендации

1. **Когда объединять в Pod**:

    * Процессы должны:

      * Иметь общий жизненный цикл
      * Требовать тесной интеграции
      * Совместно использовать данные
2. **Когда разделять**:

    * Процессы могут масштабироваться независимо
    * Разные команды отвечают за разные компоненты
    * Требуется разное аппаратное обеспечение
3. **Ограничения**:

    * Все контейнеры в Pod'е должны работать на одной ноде
    * Невозможно обновить отдельный контейнер без пересоздания Pod'а

### Пример: Pod с инициализирующим контейнером (init container)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: init-demo
spec:
  containers:
  - name: app
    image: nginx
    volumeMounts:
    - name: config
      mountPath: /etc/nginx
  initContainers:
  - name: config-loader
    image: busybox
    command: ['sh', '-c', "cp /tmp/config/* /etc/nginx/"]
    volumeMounts:
    - name: config
      mountPath: /etc/nginx
    - name: source
      mountPath: /tmp/config
  volumes:
  - name: config
    emptyDir: {}
  - name: source
    configMap:
      name: nginx-config
```

Этот механизм позволяет создавать сложные многокомпонентные приложения, сохраняя при этом тесную интеграцию между частями системы.

‍

## Развертывание панели управления Kubernetes и доступ к ней

Инструкция: https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/

‍

## Ссылки

Документация:

Pods: https://kubernetes.io/docs/concepts/workloads/pods/#working-with-pods

‍

‍
